// da3.hpp
// Elliott Lewandowski
// 2024-09-26
//
// For CS 311 Fall 2024
// Header for Assignment 3 functions
//
// Acknowledgement: The skeleton for this file was
//      written by Glenn G. Chappell

#ifndef FILE_DA3_HPP_INCLUDED
#define FILE_DA3_HPP_INCLUDED

#include "llnode.hpp"  // For LLNode
#include <cstddef>     // For std::size_t
#include <functional>  // For std::function
#include <stdexcept>   // For std::out_of_range
#include <iterator>    // For std::next, std::advance

// Preconditions:
//    head must point to a properly allocated llnode or be a nullptr,
//    index must be less than the length of the linked list
//    index must be non negative
template <typename ValueType>
ValueType lookup(const LLNode<ValueType> * head,
                 std::size_t index)
{
    if (static_cast<int>(index) < 0)
        throw std::out_of_range("lookup: index out of range, negative");
    
    auto current = head;
    int counter = 0;

    while(current != nullptr && counter < static_cast<int>(index)){
        current = current->_next;
        ++counter;
    }

    // If current != nullptr here then counter == index and we can return _data
    if (current == nullptr)
        throw std::out_of_range("lookup: index out of range, reached end of linked list before reaching index");
    
    return current->_data;
}


// Implementation in source file
// Possible Exceptions: 
//    This function will rethrow any exceptions generated by function ff
// 
// Preconditions:
//    ff must be either a function pointer or an object that acts like a function 
void didItThrow(const std::function<void()> & ff,
                bool & threw);


// Preconditions:
//    first must be an iterator at the start of a range,
//    last must be an iterator at the end of the same range,
template <typename FDIter>
bool checkSorted(FDIter first,
                 FDIter last)
{
    // Ensure we have a size greater than 0 before incrementing iterators
    if (first == last)
        return true;

    auto current = std::next(first);
    auto prior = first;

    while (current != last)
    {
        if (*current < *prior)
            return false;
        
        prior = current;
        current = std::next(current);
    }

    return true;
}


// Implementation in source file
//
// Possible Exceptions: 
//    Does not throw
//
// Preconditions:
//    a and b must be non-negative
//    a and b cannot both be 0

int gcd(int a,
        int b);


#endif  //#ifndef FILE_DA3_HPP_INCLUDED

